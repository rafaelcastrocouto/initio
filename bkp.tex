\documentclass[dm,ppgcomp]{texfurg}
\usepackage[utf8x]{inputenc}
\usepackage{graphicx}


\title{Uma aplica{\c{c}}{\~a}o Web para implementa{\c{c}}{\~a}o do modelo AB de dobramento de prote{\'i}­nas}

\advisor[Prof.]{Machado}{Karina dos Santos}
\coadvisor[Prof.]{Emmendorfer}{Leonardo}
\author{Couto}{Rafael Castro do}
\keyword{Javascript}
\keyword{Dobramento de prote{\'i}­na}
\keyword{Bioinform{\'a}tica}
\keyword{Modelo AB}

\date{\today}

\usepackage{natbib}
\usepackage{graphicx}

\setlength{\emergencystretch}{18pt}

\begin{document}

\maketitle

\begin{abstract}

O problema de dobramento de proteínas continua presente como um desafio na área de Bioinformática. Com o objetivo de isolar e entender alguns aspectos desse problema, a comunidade científica tem proposto uma série de modelos altamente simplificados, porém não triviais. Este trabalho apresenta um modelo de polímero contínuo simplificado que incorpora características estruturais essenciais e considera as interações entre os resíduos (aminoácidos) chamado Modelo AB. Este modelo foi desenvolvido para explorar a adaptação de redes neurais na predição de padrões de dobramento de proteínas na forma de estrutura primária (sequência de aminoácidos). Atualmente existem diversas implementações para a solução do dobramento de proteínas com o uso do modelo AB que despendem um longo tempo de execução em máquinas de alta performance. 

O objetivo do presente trabalho é desenvolver uma aplicação que ilustre o problema de dobramento de proteína usando o Modelo AB. A aplicação desenvolvida incorpora uma soluçao inspirada nos algoritmos de estimação de distribuição e em estratégias de aprendizagem de máquina para a busca da solução ótima. Essa solução ainda utiliza conceitos das meta-heurísticas de arrefecimento simulado para execcutar o refinamento dos dobramentos obtidos.

Sendo assim, este trabalho propõe uma nova abordagem na solução do problema de dobramento de proteínas através de uma interface de programação de aplicativos em desenvolvida em Javascript. Espera-se que o conteúdo elaborado tenha um efeito estimulante no desenvolvimento de novas ferramentas para lidar com o problema de dobramento de forma integrada com o desenvolvimento Web.

\end{abstract}

\begin{englishabstract}
  {An implementation of the AB model in a web application}
  {Javascript, keyword-two, keyword-three, keyword-four}

The protein folding problem continues to present scientific challenges in the area of Bioinformatic. In an effort to isolate and clarify a few aspects of protein folding, the scientific community has proposed several highly simplified, but still non trivial, models. The present paper concerns an example of continuum polymer models that incorporate simplified backbone potentials and inter amino acids interactions called AB Model. It was developed to explore the adaptation of neural networks to prediction of folding patterns of proteins from their primary structure (amino acid sequence along the backbone) Several implementations aim to solve the protein folding problem through the AB Model, often using techniques of machine learning, along with algorithms without friendly interface and with long run time even on high performance machines.

P.....

Thus, the objective in the present work is to develop a web application that handles all these concepts and illustrate the protein folding problem using the AB Model. The developed application implements this model, and incorporates a solution inspired by distribution estimation algorithms for refinement of folding obtained. It is our hope that the content offered below will have a stimulating effect in development of new tools to cope with web development  along with the general protein folding problem.

.....

\end{englishabstract}

%Lista de Figuras
\listoffigures

%Lista de Tabelas
\listoftables

%lista de abreviaturas e siglas
\begin{listofabbrv}{SPMD}

        \item[API] Application Programming Interface
        \item[CMS] Content Management System
        \item[CSS] Cascading Style Sheet
        \item[DOM] Document Object Model
        \item[EDA] Estimation of Distribution Algorithm
        \item[EST] Expressed Sequence Tags
        \item[HTML] Hyper Text Markup Language
        \item[JS] JavaScript
        \item[PHP] Hypertext PreProcessor
        \item[SQL] Structured Query Language
        \item[URI] Uniform Resource Identifier
        \item[W3C] World Wide Web Consortium
        \item[WWW] World Wide Web

\end{listofabbrv}

%Sumario
\tableofcontents

\chapter{Introdução}

Uma proteína pode ser definida como um polímero linear composto por aminoácidos  ou como um composto orgânico constituído por um ou mais polipeptídeos. Os aminoácidos são moléculas orgânicas que se unem através de ligações peptídicas, formando os peptídeos e a estrutura primária da proteína. Os aminoácidos são de diversos tipos e sua classificação é extensiva, podendo ser classificados quanto ao radical e quanto ao seu destino.

Sabe-se que uma proteína pode ser formada por milhares de aminoácidos e sua sequência influencia diretamente na conformação final da proteína [1] . A sequência de aminoácidos ao longo da cadeia polipeptídica é denominada estrutura primária. 

O arranjo espacial de aminoácidos próximos entre si na sequência primária da proteína forma a estrutura secundária, que se caracteriza por duas formações principais: as alfa-hélices e as folhas-beta, além de estruturas que não são nem hélices nem folhas, chamadas alças. 

Enquanto a estrutura secundária é determinada pelo relacionamento estrutural de curta distância, a terciária é caracterizada pelas interações de longa distância entre aminoácidos, denominadas interações hidrofóbicas, pelas interações eletrostáticas, pontes de hidrogênio e de sulfeto.
Finalmente, algumas proteínas podem ter duas ou mais cadeias polipeptídicas, a conformação dessas cadeias em estruturas tridimensionais é a estrutura quaternária.

A forma de uma proteína determina sua função, portanto a sequência de aminoácidos pode predizer o comportamento de uma determinada proteína no organismo. Entender como se define a forma de uma proteína (dobramento) é um desafio para a comunidade científica.

Existe a hipótese de que a estrutura terciária pode ser determinada a partir da  sequência primária, o que permitiria que algoritmos fossem desenvolvidos para predizer estruturas terciárias quando a primária estivesse disponível. 

Porém está é uma tarefa extremamente complexa com altas demandas computacionais mesmo para proteínas pequenas. O problema de dobramento de proteínas é extremamente difícil e pertence a uma classe de problemas denominados NP-completos.

Com o objetivo de facilitar o desenvolvimento de soluções para o complexo problema do dobramento de proteínas foram desenvolvidos modelos simplificados [2] . Estes modelos mantém as características relevantes das proteínas e reduzem a demanda computacional para a busca da solução, além de agilizar a implementação de novas soluções. Este trabalho utiliza um destes modelos simplificados denominado modelo AB.

Diversos algoritmos foram implementados com o objetivo de prever a conformação de menor energia de uma proteína-alvo. Dentre eles vale destacar as Redes Neurais [3] , Algoritmos Genéticos e os Algoritmos de Distribuição Estimada (EDA).

O objetivo deste trabalho é desenvolver uma aplicação, que implemente um novo algoritmo para o problema de dobramento de proteínas. O algoritmo proposto neste trabalho se inspira nos EDA  e em técnicas de Aprendizagem de Máquina e de Arrefecimento simulado (Simulated Annealing).
Tanto as heurísticas e técnicas de aprendizagem de máquina quanto os algoritmos de otimização podem ser implementados através de diferentes tecnologias. Uma  possibilidade interessante do ponto de vista do desenvolvimento consiste na implementação desse algoritmo utilizando tecnologias Web. Essas tecnologias são voltadas à execução paralela e distribuída e seu código interpretado simplifica o desenvolvimento, além de tornar a publicação e compartilhamento extremamente rápidos e simples.

O algoritmo foi implementado em uma aplicação em Javascript, onde também foram desenvolvidas as estruturas virtuais das proteínas simplificadas e os cálculos da energia. Com a aplicação foram gerados gráficos do espaço de soluções para tetrâmeros, simulações das estruturas, os algoritmos e os gráficos do comportamento da energia ao longo da busca.
Foram implementados ainda, modelos interativos, onde é possível alterar manualmente os ângulos e acompanhar a energia calculada em tempo real. Todas as implementações podem ser renderizadas em um navegador de internet atual.

No próximo capítulo, é apresentado um resumo dos conceitos relevantes ao problema, como a abrangente área de estudos da Bioinformática, às classes de complexidade de problemas como o problema de dobramento e o modelo simplificado usado neste trabalho.
Os trabalhos que serviram de base para o desenvolvimento do algoritmo são relacionados no terceiro capítulo, com o objetivo de apresentar a evolução do modelo e da busca pela solução.
O quarto capítulo descreve como foi implementada a aplicação e como ela será desenvolvida nos próximos meses. Em seguida, encontra-se o algoritmo proposto e descreve-se como foi desenvolvida esta proposta.  

\chapter{Bioinformática}

Bioinformática pode ser considerada uma área de conhecimento multidisciplinar que envolve uso intensivo de ferramentas computacionais. Nessa área, os computadores são usados para resolver problemas na área de ciências biológicas, envolvendo principalmente a manipulação de grandes bancos de dados, como sequências de proteínas, entre outros. De forma complementar, também envolve técnicas como modelagem tridimensional de proteínas e de outros sistemas biológicos, estudos de filogenia, desenho racional de fármacos, etc. [4] .

De forma resumida, a Bioinformática tem como objetivos principais a coleta, organização, armazenamento, recuperação e análise de dados biológicos, propiciando a inferência ou descoberta de informações sobre a biologia e/ou evolução dos organismos.

Inúmeros projetos transnacionais de grande importância, por exemplo, o Projeto Genoma Humano, se destacam no campo da Bioinformática. No Brasil, existem também  inúmeros projetos que envolvem tanto o sequenciamento, quanto análises genômicas e/ou proteômicas de organismos que provocam patogenias. Como por exemplo o sequenciamento genético da bactéria Xylella fastidiosa [5] ; as iniciativas do consórcio RioGene envolvido com o mapeamento e anotação das sequências nucleotídicas das bactérias Gluconacetobacter diazotrophicus.

Finalmente, ressalta-se os trabalhos do projeto BioWebDB (2008), relacionados não só com o sequenciamento e anotações de genomas, como também no desenvolvimento de novas ferramentas para a área da bioinformática. 

Um dos problemas mais importantes dentro da área de Bioinformática e Biologia computacional que continua em aberto é a predição do dobramento de proteínas. Conferências anuais são realizadas em diversos países para tratar especificamente desse problema e das pesquisas que objetivam para sua solução. Trata-se de um problema complexo e que será discutido no próximo capítulo.

\chapter{Dobramento de Proteínas}

A palavra proteína deriva da palavra grega protos, significando “primeiro” ou “mais importante”. O nome é de certa forma apropriado, pois apesar de constituírem apenas cerca de 20\% da massa orgânica nos seres vivos, são a mais versátil classe de compostos orgânicos. Os papéis que desempenham nos sistemas biológicos são muito diversos; catálise de reações, transporte, suporte e movimento, resposta imunitária, entre outros. A figura \ref{figura1} mostra um exemplo de proteína e sua forma de estrutura terciária, é nesta forma que a proteína exerce sua função.

\begin{figure}[htbp]
  \centering \includegraphics[scale=0.5]{universe.jpg}
\caption{Exemplo de modelo tridimensional de proteína.} 
\label{figura1}
\end{figure}

Considerando a importância do processo de dobramento das proteínas para a definição de sua funcionalidade no metabolismo dos organismos, muito esforço tem sido feito na tentativa de compreender seu funcionamento. Apesar de muito conhecimento ter sido gerado, ainda restam muitas perguntas a serem respondidas e esse fato é agravado pelo estudo do genoma humano, que tem aumentado muito a quantidade de proteínas a serem estudadas [6] . 

A compreensão do processo de dobramento de proteínas é de fundamental importância para a área da saúde, podendo ser utilizado na dedução de relações evolutivas; para, por exemplo, a criação de drogas inteligentes e, para o entendimento de algumas doenças como câncer, fibrose cística, encefalopatia espongiforme bovina (doença da vaca louca), mal de Alzheimer, mal de Parkinson e diabetes tipo II, que são causadas por aglomerações de proteínas mal dobradas que não desempenham corretamente sua função e danificam as células saudáveis [7] .

A sequência de aminoácidos específica de uma proteína, também denominada estrutura primária, dobra-se para tomar a sua configuração natural. Apesar destas macromoléculas aparentarem estar a dobrar-se a si mesmas, a sua dobra muda de acordo com as características das moléculas que as rodeiam, incluindo a concentração dos sais, a pressão, a temperatura, enfim de infinitos elementos. O dobramento é um processo espontâneo, natural.

A comunidade científica têm estudado muitas moléculas idênticas dobrando-as simultaneamente em larga escala. Percebe-se que na transição para o estado natural, uma dada sequência de aminoácidos percorre, de forma geral, o mesmo caminho, passando pelos mesmos estados intermediários [1] .

Pode-se dizer que, o dobramento envolve o estabelecimento de uma estrutura secundária, particularmente hélices-alfa e folhas-beta, e depois uma estrutura terciária. O ponto essencial no dobramento é, no entanto, o fato da sequência de aminoácidos especifica de cada proteína conter a informação que indica a sua conformação final e o caminho para atingir esse estado.

A conformação nativa de uma proteína é frequentemente a configuração termodinamicamente mais estável, ou seja, que possui menor energia livre. Assim, podemos descrever o problema de Predição de Estruturas de Proteínas como um problema de otimização, onde a estrutura com menor energia livre deve ser encontrada dentre todas as possíveis estruturas. 

Entretanto este é um problema NP completo [8] , no qual métodos tradicionais de otimização, em geral, não apresentam bom desempenho. Com o objetivo de facilitar o desenvolvimento de métodos para solucionar o problema, modelos simplificados são utilizados, como o modelo AB que é apresentado a seguir.

\chapter{Modelo AB}

De forma a desenvolver soluções para o complexo problema do dobramento de proteínas foram desenvolvidos modelos, sendo os mais disseminados o Modelo HP e o Modelo AB, para a descrição de uma proteína simplificada, de forma a facilitar o desenvolvimento de novas soluções. 

No modelo de dobramento AB, a proteína é descrita como uma sequência de aminoácidos hidrofóbicos (A) e hidrofílicos (B). Apesar de nem todos os aminoácidos serem hidrofóbicos ou hidrofílicos, nós trabalharemos somente com estes dois tipos neste modelo. Muitas propriedades como massa, volume e carga eletromagnética também não são consideradas. 

Esse modelo é uma evolução do modelo HP, no qual os aminoácidos sofrem as mesmas simplificações, porém seus ângulos são restringidos à uma grade ortogonal [12] . 

A figura 2 apresenta uma estrutura simplificada com treze aminoácidos em seu estado mais estável, onde “a” representa segundo ângulo entre os aminoácidos. Em nosso modelo os ângulos estarão restritos entre ($-\pi, \pi$). 

\begin{figure}[htbp]
  \centering \includegraphics[scale=.3]{universe.jpg}
\caption{Estrutura de proteína no modelo AB.} 
\label{figura3}
\end{figure}

A função 1 será usada para calcular a energia de um modelo de proteína-alvo em uma determinada conformação:

\[
E=(1/4)\sum_{i=1}^{(N-2)}(1+cos\theta_{i, i+1})+4\sum_{i=1}^{(N-2)}\sum_{j=i+2}^{(N-2)}(d^{-12}_{i, j}-C (a_{i}, a_{j})d^{-6}_{i, j})
\]

Sendo:\\
$C (A, A) = 1$\\
$C (B, B) = 0.5$\\
$C (A, B) = C (B, A) = -0.5$\\

Função 1: Cálculo da energia de uma proteína no modelo AB. \\

Onde “$E$” representa a energia, “$N$” simboliza o comprimento da sequência de aminoácidos, “$a$” é o tipo do aminoácido ($A$ ou $B$), “$C$” são as cargas dadas, “$\theta$” é o ângulo e “$d$” a distância entre os aminoácidos.

O pseudo código da função 2 demonstra como é calculada a energia de um modelo de  proteína em uma determinada conformação, dadas as distâncias, as cargas e os ângulos:

\[
v1 = 0, v2 = 0;
for (i = 1; i < (n - 2); i++) {
  v1 += (1 + cos(ang[i])) / 4;
}
for (i = 0; i < (n - 2); i++) {
  for (j = (i + 2); j < n; j++) {
    v2 += 4 * (pow(d(i,j), -12) – c(i,j) * pow(d[i][j], -6));
  }
}
energy = v1 + v2;
\]

Função 2: Pseudo código do cálculo da energia do modelo de proteína

As sequências de aminoácidos foram geradas de acordo com a sequência de Fibonacci [11] , onde o próximo elemento é resultado da concatenação dos últimos dois elementos. O objetivo é evitar padrões repetitivos e simétricos, tornando o modelo mais próximo de uma proteína real. A sequência segue a forma a seguir:

\[
f(0) = 0; f(1) = 1; f(n) = f(n-2) + f(n-1); Ex: 0, 1, 1, 2, 3, 5, 8, 13, 21, …
\]

Função 2: Aplicação da sequência de Fibonacci.\\

No nosso caso, usaremos a letra “$A$” para aminoácidos hidrofóbicos e a letra “$B$” para os hidrofílicos, portanto as sequências ficarão assim:

\[
f(0) = A; f(1) = B; f(n) = f(n-2) + f(n-1); Ex: A, B, AB, B AB, AB BAB, BAB ABBAB, …
\]

Função 3: Sequência de Fibonacci aplicada à sequência de aminoácidos.\\

Utilizaremos para testes quatro sequências que utilizam esse método sendo elas:

\[
FIBO6(13) = ABBABBABABBAB;
FIBO7(21) = BABABBABABBABBABABBAB;
FIBO8(34) = ABBABBABABBABBABABBABABBABBABABBAB;
FIBO9(55) = BABABBABABBABBABABBABABBABBABABBABBABABBABABBABBABABBAB;
\]

Além dos modelos gerados a partir da série de Fibonacci também serão utilizadas duas sequências inspiradas em proteínas existentes. Essas sequências são adaptações de sequências primárias conhecidas e seu objetivo é aproximar ainda mais o modelo de uma situação real, sendo a primeira  denominada “1AGT” e a segunda “1AHO”. Para obter suas cadeias, os aminoácidos tipo I, V, L, P, C, M, A e G são considerados hidrofóbicos e representados pela letra “$A$” e os resíduos D, E, F, H, K, N, Q, R, S, T, W e Y considerados hidrofílicos e representados pela letra “$B$” ***referencia***.

\[
1AGT(38) = GVPINVSCTGSPQCIKPCKDAGMRFGKCMNRKCHCTPK
           AAAABABABABABAABAABBAAABBABAABBBABABAB
           
1AHO(64) = VKDGYIVDDVNCTYFCGRNAYCNEECTKLKGESGYCQWASPYGNACYCYKLPDHVRTKGPGRCH
           ABBABAABBABABBBAABBABABBBABBABABBABABBABABABAABABBAABBABBBAAABAB
\]


Apesar das simplificações serem consideráveis a solução do problema está longe de ser trivial e o modelo ainda conserva características de proteínas reais, como o surgimento de pequenos padrões de dobra, a formação de núcleos hidrofóbicos compactos e protegidos [8] , entre outros.

\chapter{Classes de Complexidade}

O conjunto de problemas que podem ser resolvidos em tempo Polinomial por uma
máquina de Turing determinística é denominado P, qualquer problema deste conjunto pode ser
resolvido por um algoritmo com tempo de execução O (n^k), com k constante [8] .

O conjunto de problemas que são decidíveis em tempo Polinomial por uma máquina de Turing Não-determinística é denominado NP. Um subconjunto de NP denominado NP-completo é um conjunto cujos problemas precisam satisfazer a seguinte condição: todo problema em NP é redutível para este problema em tempo polinomial. Portanto, se tivéssemos um algoritmo de tempo polinomial para resolver um problema NP-completo, podíamos resolver todos os problemas NP em tempo polinomial.

Para ilustrar a complexidade do problema de dobramento, foi desenvolvida uma
aplicação que mapeasse a energia em todas as conformações possíveis de uma proteína
simplificada de acordo com o modelo AB. Com o objetivo de gerar gráficos bidimensionais,
foram usadas tetrâmeros pois, como o primeiro e o último ângulo não alteram a conformação,
ficamos com uma matriz de dois ângulos de comprimento. 

O primeiro ângulo é usado no eixo horizontal (x) e o segundo no eixo vertical (y). Os
ângulos variam entre -π e +π radianos, de forma que no centro de cada eixo estará o ângulo 0.
No centro do gráfico estará a proteína em sua conformação linear.

O valor da energia de cada conformação está apresentado em cores com valor mínimo
indicado em cada gráfico. Os valores de energia acima de um estão em vermelho enquanto os
valores menores que um são graduados linearmente de acordo com a barra de cores;

Note que devido à baixa resolução dos ângulos o valor mínimo não é a verdadeira
solução do problema, porém as proteínas apresentam a conformação correta.

O cálculo e a renderização de cada gráfico apresentado na figura 3 demorou, em média,
oitenta milésimos de segundo em um computador atual com processador de dois giga-hertz e
seis giga-bytes de memória de acesso aleatório (RAM)

\begin{figure}[htbp]
  \centering \includegraphics[scale=.3]{universe.jpg}
\caption{Espaço de soluções bidimensional para um tetrâmero.} 
\label{figura3}
\end{figure}

Nos gráficos, mesmo os modelos cuja solução é linear, a distribuição é única para cada sequenciamento. No sexto gráfico, onde todos aminoácido são hidrofóbicos, é possível perceber ótimos locais em conformações não lineares.

A geração de um único gráfico com uma resolução acima, de vinte ângulos, ou seja, de π / 10 radianos, para uma proteína de quatro aminoácidos, resulta na computação de quatrocentos (202) modelos de proteínas. É possível encontrar este valor através da seguinte  fórmula: P = R(N – 2), onde P é o número de modelos de proteínas possíveis, R é a quantidade de ângulos para cada aminoácido e N é o comprimento da cadeia primária. 

Supondo a geração de um gráfico multidimensional com a mesma resolução para uma proteína de somente doze aminoácidos, seriam calculadas mais de 4 x 1015 modelos de proteínas. Se o cálculo de um único modelo demorar um milésimo de segundo, a suposta geração do gráfico demoraria mais de cento e vinte mil anos. 

Portanto, buscar uma solução que explore linearmente o espaço de busca demanda um tempo de computação absurdo. A solução é implementar outras formas de busca, que introduzem métodos lógicos e heurísticas para direcionar o algoritmo e aumentar a performance, diminuindo drasticamente o tempo de computação.

\chapter{Trabalhos relacionados}

Predizer a estrutura nativa de uma proteína a partir de sua sequência é um dos problemas mais difíceis no campo da Bioinformática. Esta dificuldade provem de dois aspectos: O tamanho do sistema é normalmente imenso, na mesma ordem do número de átomos envolvidos e o espaço de soluções é extremamente complexo. Este espaço de soluções pode ser descrito como uma série de mínimos locais, separados por barreiras com altíssimos valores energéticos.

Anfisen [1] analisa de forma minuciosa o dobramento de proteínas reais percebendo uma série de aspectos do problema, como a conformação de padrões locais. Porém, mesmo percebendo a complexidade do problema, considera que com a crescente quantidade de dados disponível e com a evolução teórica, a ideia de prever o dobramento de proteínas começava a se tornar mais realista.

De acordo com a hipótese de Anfisen, a estrutura terciária nativa de uma proteína pode ser determinada a partir da informação contida na sequência primária, o que permitiria que métodos computacionais fossem desenvolvidos para predizer estruturas terciárias quando a primária estivesse disponível. No entanto, ainda não existe uma ferramenta computacional capaz de predizer com exatidão a estrutura tridimensional para uma grande variedade de proteínas.

Em 1993, Stillinger, Head-Gordon e Hirshfeld publicaram em [2] um modelo de proteínas simplificado e iniciaram os estudos desse modelo através de algoritmos baseados em  redes neurais. Nesse artigo, são analisadas trímeros, tetrâmeros e pentâmeros, e é apresentada uma tabela com as conformações de menor energia para todas estas sequencia de aminoácidos.

Graças a essa análise é possível perceber que algumas sequencias de aminoácidos deste modelo apresentam como conformação mais estável, ou seja, de menor energia, uma proteína linear. Estes casos não são relevantes para o problema de dobramento pois o objetivo do modelo é encontrar conformações similares às encontradas na natureza.

Por isso, no artigo [3] , Stillinger ressalta a importância da sequencia de aminoácidos para o modelo AB e analisa diferentes sequencias para proteínas maiores, de até 55 aminoácidos. Dois tipos de sequencias são analisadas, o primeiro tipo é denominado “Center Doped” e usa o padrão (An – B – An), enquanto o segundo se inspira na  série de Fibonacci.

As proteínas geradas a partir de sequencias de Fibonacci apresentaram características muito relevantes como a conformação de padrões locais e soluções distintas para diferentes  polímeros, por isso este trabalho utiliza este sequenciamento. Stillinger reafirma ainda a imensa dificuldade computacional intrínseca em prever o dobramento de grandes proteínas. 

Stillinger, no artigo em que apresenta o Modelo AB ***referencia*** , utiliza algoritmos de Redes Neurais para obter seus primeiros resultados. Também conhecidos como Redes Neurais Artificiais, são algoritmos que simulam os neurônios no seu funcionamento e são muito eficientes em métodos de classificação. Apesar de apresentarem bons resultados na predição do dobramento de proteínas, em geral as Redes Neurais apresentam diciculdade em expor os princípios que levaram à solução, ou seja, o motivo de determinados padrões ser considerados ou não e, a partir dessas informações, chegar a regras úteis para modelos mais complexos.

Outras formas de explorar o problema já bastante pesquisadas são as técnicas baseadas no Método de Monte Carlo. Este método consiste em gerar amostragens aleatórias para obter resultados numéricos. Muito comumente utilizado quando a distribuição probabilistica do espaço de busca é desconhecida, como é o caso do problema de dobramento. Dentre essas técnicas, a que apreentou resultados mais relevantes é denominado Annealing Contour Monte Carlo (ACMC) **referencia **, uma evolução do Contour Monte Carlo (CMC).

Em um artigo muito influente na pesquisa sobre o dobramento de proteínas, Unger e Moult ***referencia*** descrevem um Algoritmo Genético que utiliza cruzamento baseado em heurísticas e operadores de mutação para resolver o modelo HP. O algotimo genético foi capaz de superar o Monte Carlo em diferentes sequências. É importante salientar que os algoritmos propostos para solucionar o modelo HP podem não ser extensíveis ao modelo AB devido ao formato das soluções não discreto. E, mesmo naqueles em que é possível uma adaptação, pode resultar em uma grande perda de eficiência.

Algoritmos de Estimação de Distribuição (EDAs) são algorimos evolutivos que constroem um modelo probabilístico explícito a partir de um conjunto de soluções selecionadas. Desta forma, pode-se captar interações relevantes entre as variáveis do problema, analisando prováveis dependências existentes. Um algoritimo de estimação de distribuição utilizando o modelo de Markov ***referencia*** apresentou resultados ainda melhores que os de outros métodos baseados em populações ou conjuntos de soluçoes.

Outras técnicas que merecem destaque no campo do dobramento são: Conventional Metropolis Monte Carlo, Multicanonical Monte Carlo, Pruned-Enriched Rosenbluth, Simulated Tempering e Artificial Bee Colony. Todos algoritmos apresentados neste artigo compartilham do mesmo desafio: Ultrapassar as barreiras energéticas do espaço de soluções e fugir dos ótimos locais para atingir a real solução do problema. 

\chapter{Algoritmo implementado baseado em Simulated Annealing}

Existe uma conexão forte e útil entre mecânica estatística (o comportamento de sistemas com muitos graus de liberdade em equilíbrio térmico a uma temperatura finita) e otimização multivariada ou combinatória (encontrar o mínimo de uma função dada, dependendo de vários parâmetros) [9] .

Simulated Annealing é uma meta heurística genérica para problemas de otimização global que consiste numa técnica de busca local probabilística. É usada normalmente em grandes espaços de busca e se fundamenta numa analogia com a segunda lei da termodinâmica. Seu nome é inspirado no processo de recozimento, utilizado em metalurgia para obtenção de estados de baixa energia num sólido. Neste processo, o metal é inicialmente aquecido à altas temperaturas e, em seguida, é resfriado lentamente e seu resfriamento é acompanhado e controlado de acordo com funções específicas. 

De forma análoga a este processo, foi desenvolvido um algoritmo que substitui a solução atual por uma solução próxima, escolhida de acordo com uma função objetivo e com uma variável (no caso do recozimento, com o valor da temperatura). À medida que o algoritmo progride, o valor da variável é decrementado, fazendo o algoritmo a convergir para uma solução ótima local. No problema de dobramento essa variável com o valor inicialmente alto representa o ângulo entre os aminoácidos e a função objetivo é a função 1 apresentada na seção 2.3  para cálculo da energia da proteína.

Inicialmente, foi implementado um algoritmo com as características desta meta-heurística que apresentou resultados interessantes. Apesar deste algoritmo não ter bons resultados no início da busca, se demostrou excelente em refinar as soluções. Este algoritmo é extremamente simples e funciona da seguinte forma, o valor inicial "A" de um ângulo é determinado pelo usuário. Dado um número também determinado de etapas, cada angulo do modelo é alterado nas duas direções, positiva e negativa, calculando a energia de ambas conformações. É escolhida então a conformação mais estável entre as três e decrementado o valor de "A". Caso o limite ainda não tenha sido atingido, inicia-se então uma nova etapa.


////ORGANOGRAMA ANN



Devido ao fato de o algoritmo não apresentar ferramentas para escapar de situações em que a conformação apresenta um valor de energia baixo em relação às conformações vizinhas (ótimos locais), a busca não parte para uma conformação inicial promissora. Em outra palavras, o algoritmo não ultrapassa as barreiras energéticas entre os ótimos locais. Porém, dada uma conformação com características levemente próximas àquelas apresentadas na solução do problema, o algoritmo se demonstrou muito eficaz em finalizar a busca, ajustando os ângulos até a melhor conformação local.

Com esse resultado em mãos, este algoritmo passa então a ser executado ao fim de cada teste para refinar a solução encontrada por outros métodos. Por isso foi desenvolvido outro algoritmo, com o objetivo de aprimorar a busca por dobramentos iniciais, levando em consideração a problemática relacionada aos ótimos locais. Este novo algoritmo é descrito a seguir.

\chapter{Algoritmo Proposto baseado em EDAs}

Para satisfazer as necessidades percebidas pela implementação anterior, foi desenvolvida uma solução que utilizasse técnicas menos diretas, que tratassem o problema em um nível mais subjetivo. Buscou-se então, conceitos mais abrangentes, que pudessem ser aplicados à diversas classes de problemas. Dentre esses conceitos, dois foram os que serviram de inspiração para esta proposta: o conceito de  Aprendizagem de Máquina (Machine Learning) e os algoritmos genéticos, mais particularmente os Algoritmos de Distribuição Estimada, apresentados a seguir.
 
O conceito de Aprendizagem de Máquina de acordo com Tom M. Mitchell gira em torno de aprender com a experiência [10] . Um programa de computador é dito capaz de  aprender com a Experiência "E" a respeito de uma classe de Tarefas "T" com Performance "P", se a performance nas mesmas tarefas "T", melhora em relação à "P" devido à experiência "E". Ou seja, pode-se dizer que uma máquina aprende, se ela melhora sua performance na solução de um problema através da experiência acumulada nas soluções anteriores. 

Os resultados das tarefas ou exemplos de treinamento têm uma distribuição de probabilidade de certa forma desconhecida. A máquina aprendiz tem que extrair deles algo mais geral, algo sobre a sua distribuição, que lhe permitirá produzir previsões úteis em novos casos.

Aplicamos esse conceito à nossa tarefa, o dobramento de proteínas, de forma que, a cada dobramento, um dado ou parâmetro proveniente da busca pela solução fosse armazenado. Armazenamos essa memória nos parâmetros, que guardam a experiência do algoritmo. Ao gerar novos dobramentos o algoritmo usa os parâmetros para obter melhores soluções. Através desta heurística, os parâmetros se adaptam na medida que a busca prossegue, de forma a direcionar a busca. 

Os Algoritmos de Distribuição Estimada (EDA) pertencem à classe de algoritmos evolutivos e também serviram de inspiração para a solução proposta. Esses algoritmos já foram aplicados ao problema de dobramento e inclusive elaborados [11] apresentando resultados promissores. A principal diferença entre EDA e algoritmos evolutivos mais convencionais é que os algoritmos evolutivos geram novas soluções candidatas utilizando uma distribuição implícita definida por um ou mais operadores de variação, enquanto EDA utiliza uma distribuição de probabilidade, que pode ser codificada por uma rede Bayesiana, uma distribuição normal multivariada, ou outra classe de modelo.

A principal inspiração proveniente dos EDAs para o algoritmo proposto foi a de utilizar fatores de aleatoriedade sempre guiados explícitamente por valores específicos. Esses valores são extraídos da própria solução do problema e por isso moldam probabilísticamente o caminho para a solução. Com esses conceitos em mente, foi desenvolvido o algoritmo, denominado Algoritmo de Aprendizagem Estimada, onde esses valores são usados para selecionar e gerar ângulos. 

O algoritmo proposto parte de uma proteína linear e através de dois parâmetros básicos (Rigidez e Eficiência), ajusta os ângulos sucessivamente. Após cada ajuste, ou dobra, a energia da proteína é calculada e os parâmetros são atualizados com base nos resultados.



////ORGANOGRAMA ELA



O parâmetro denominado Eficiência (efficiency) é aplicado no momento em que é selecionado o ângulo onde será realizada a dobra. Esta seleção é aleatória e multinomial, sendo que quanto maior a Eficiência de um aminoácido do modelo, maior a chance dele ser selecionado. A Eficiência de um aminoácido aumenta quando a dobra realizada aumenta a estabilidade da proteína, assim o algoritmo aumenta as chances de sucesso das dobras seguintes. A Eficiência é inicializada com valor um para todos os aminoácidos. 

A cada passo, são alterados um numero determinado de ângulos ao longo da estrutura primária. Este número de angulos tem relação íntima com o comprimento da cadeia. Na situação onde se alteram muitos ângulos, a informação relacionada à quais destes ângulos contribuiu para a solução se torna menos relevante. Porém quando se altera somente um ângulo por vez, torna-se impossível solucionar o problema sem aceitar soluções energéticamente superiores. Isso se deve ao fato de que, ao alterar somente um ângulo, estamos 'caminhando' por uma única dimensão no espaço de soluções. É visível o fato que não há um caminho constituído por linhas ortogonais que leve à solução ótima sem passar por soluções altamente instavéis.

A figura 5 apresenta um modelo com cinco aminoácidos e os parâmetros iniciais usados pelo algoritmo:

\begin{figure}[htbp]
  \centering \includegraphics[scale=.3]{universe.jpg}
\caption{Inicialização dos Parâmetros do algoritmo proposto.} 
\label{figura3}
\end{figure}

A Rigidez (rigidity) influencia diretamente no valor do incremento do ângulo gerado em cada novo dobramento, sendo que quanto mais rígido, menor provavelmente será o novo ângulo. Dessa forma, no início da busca teremos maiores mudanças e, na medida em que a proteína se dobra em estados mais estáveis, a Rigidez aumenta e ângulos mais agudos são gerados, provocando assim um ajuste cada vez mais fino dos ângulos. A Rigidez é inicializada com valor um para todos os aminoácidos. Utiliza-se uma função Gaussiana que considera o valor da rigidez para gerar os valores dos novos ângulos.

Até o presente momento não foi definido nenhum critério de parada para o algoritmo, sendo que, nos testes realizados, foram utilizados valores determinados. 


\chapter{Aplicação Web}

A aplicação une os algritmos ...



Uma captura de tela da aplicação após a renderização do gráfico é apresentada na figura 6, onde pode-se perceber o declínio do valor da energia e visualizar o modelo de proteína renderizado. 

\begin{figure}[htbp]
  \centering \includegraphics[scale=.3]{universe.jpg}
\caption{Captura de tela do resultado do algoritmo.} 
\label{figura3}
\end{figure}

A função 5 demonstra o pseudo código do algoritmo apresentado.

\[

initParameters(efficiency, rigidity);
destrinchar
minProtein = protein;
while (stopCriteria) {
  a = chooseAngles(3);
  newProtein = new Protein({ang: randomGauss(a)}); 
  pushToData(newProtein);
  if (newProtein.energy < minProtein.energy) {
    minProtein = newProtein;
    adjustParameters(efficiency, rigidity, a);
  }
}
renderData();

\]

Função 5: Pseudo código do algoritmo de aprendizagem estimada

\chapter{Conclusão}

Nesse trabalho foi apresentado uma abordagem para implementar uma aplicação Web
em Javascript explorando a arquitetura cliente servidor. O resultado parece promissor, pois
seu funcionamento foi de acordo com o esperado, sem erros de nenhum tipo e com a
performance desejada. O trabalho aponta diversas áreas para pesquisas futuras que podem
tornar a arquitetura e o algoritmo mais abrangentes. 

Primeiramente, é necessário analisar questões relacionadas à performance neste modelo
de eventos (Input/Output), pois é provável que existam outras abordagens que otimizem a
performance da aplicação. Em segundo lugar, é preciso avaliar corretamente servidores e
interpretadores em Javascript e realizar experimentos com benchmarks para adquirir maior
conhecimento e confiabilidade neste tipo de aplicação.

Em relação ao algoritmo, percebe-se que além da meta análise aprofundada dos
parâmetros e métodos apresentados, para determinar a validade da proposta é fundamental a
comparação com outros algoritmos, cujos resultados sejam de qualidade reconhecida. 

Essa segunda análise é muito importante, porém não se anseia com este trabalho a
implementação de um algoritmo com resultados superiores aos métodos já altamente
elaborados pela comunidade cientifica. O que se espera é validar as técnicas propostas e
combiná-las gerando uma heurística de alto nível, que possa ser utilizada em outros
problemas similares.

\bibliographystyle{plain}
\bibliography{references}
\end{document}
